---
layout: post
title: Building a light-weight Kubernetes cluster with Raspberry Pi and k3s
date: '2019-03-31T19:00:00.000+03:00'
author: Jari Tenhunen
tags:
- Kubernetes
- containers
- Docker
- DIY
- DevOps
- Raspberry Pi
- continuous integration
modified_time: '2019-04-01T14:43:36.445+03:00'
thumbnail: https://4.bp.blogspot.com/-As86Ti0UI_Q/XKHiBir03JI/AAAAAAAAAGw/8z52--9zzHs-9mxmXCMLE4FZPD7kif7FwCLcBGAs/s72-c/k8s-db-vino-boogie-bg.png
blogger_id: tag:blogger.com,1999:blog-3014413452006891711.post-8735138831126225264
blogger_orig_url: https://blog.boogiesoftware.com/2019/03/building-light-weight-kubernetes.html
---

<!--<script src="https://cdn.jsdelivr.net/npm/gist-embed@1.0.2/dist/gist-embed.min.js" type="text/javascript"></script>--> <link href="https://jait.github.io/stylesheets/boogie-blog.css" rel="stylesheet"></link> <link href="https://jait.github.io/stylesheets/boogie-blog-gist-embed.css" rel="stylesheet"></link> <!-- <style>.gist .gist-file .gist-meta {  display: none !important; } td.js-line-number {  display: none !important; } .notice {  border-left: 3px solid rgb(0,151,162);  padding-left: 20px;  padding-bottom: 2px; } code {  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;  font-size: 0.9em; } </style>-->  <a href="https://4.bp.blogspot.com/-As86Ti0UI_Q/XKHiBir03JI/AAAAAAAAAGw/8z52--9zzHs-9mxmXCMLE4FZPD7kif7FwCLcBGAs/s1600/k8s-db-vino-boogie-bg.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="702" data-original-width="1384" height="101" src="https://4.bp.blogspot.com/-As86Ti0UI_Q/XKHiBir03JI/AAAAAAAAAGw/8z52--9zzHs-9mxmXCMLE4FZPD7kif7FwCLcBGAs/s200/k8s-db-vino-boogie-bg.png" width="200" /></a>Here at <a href="https://boogiesoftware.com/">Boogie Software</a>, our experts are using Kubernetes and container technology every day in several projects, and thus, we were quite intrigued to find out how Kubernetes works on-premises with more modest hardware. In this post, I will describe how we built a light-weight bare metal cluster on Raspberry Pi boards for running applications and services in our company network. There were really two reasons for doing this project. Firstly, by setting up the cluster we get a platform where we can reliably and flexibly run our company network internal apps and services. Secondly, this was a nice opportunity to learn more about Kubernetes technology, microservices and containerisation. For those who are interested in following these steps or building a similar system, it is recommended to have at least a basic knowledge about Docker containers, Kubernetes concepts (nodes, pods, services, deployments etc.) and IP networking.<br /><h3>Hardware setup</h3><div><div>What you would need for this kind of setup is:</div><div><ul><li>At least one Raspberry Pi 2B/3B/3B+. You can run some apps even on a single board but getting two or more boards is recommended for spreading the load and for increased redundancy.</li><li>Power supplies and SD cards for the Pis, an ethernet switch or free ports in your existing one, and some cables.</li></ul><div>In our setup, we currently have four Raspberry Pi 3 Model B+ boards, so in the cluster, there is one master/server and three agent nodes. The Raspberry Pi boards of course need some kind of housing and this is where things got a little out of hand. A fellow Boogieman who is very able with CAD and 3D printers designed and printed a neat case for the boards, which would deserve a story on its own. The casing has two fans for cooling in the back and each board sits on a tray that can be hot-swapped in and out for maintenance. The trays also have places at the front for an activity/heartbeat LED and a shutdown/power switch that both connect back to the board’s GPIO header.<br /><table style="margin-left: auto; margin-right: auto; margin-top: 1em;"><tbody><tr><td><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-U4_PE_GiyJk/XJ4k_1HrhzI/AAAAAAAAAFQ/qsy5uTepzLolgbMdC6pIUn4OFCy9VgFpwCLcBGAs/s1600/IMG_6934.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1600" data-original-width="1200" height="400" src="https://2.bp.blogspot.com/-U4_PE_GiyJk/XJ4k_1HrhzI/AAAAAAAAAFQ/qsy5uTepzLolgbMdC6pIUn4OFCy9VgFpwCLcBGAs/s400/IMG_6934.jpg" width="300" /></a></div></td><td><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-qxjBLmKLn9c/XJ4k_-hrDQI/AAAAAAAAAFU/IU5uJ1ehpVQQprug70H5edzNQYF1eVU9ACLcBGAs/s1600/IMG_6938.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1600" data-original-width="1200" height="400" src="https://2.bp.blogspot.com/-qxjBLmKLn9c/XJ4k_-hrDQI/AAAAAAAAAFU/IU5uJ1ehpVQQprug70H5edzNQYF1eVU9ACLcBGAs/s400/IMG_6938.jpg" width="300" /></a></div></td></tr></tbody></table><br /></div></div></div><div><h3>Software stack</h3></div><div>For the Kubernetes implementation, we chose to use <a href="https://k3s.io/">k3s</a> from Rancher Labs. For such a young project, it is actually very stable and usable, likely due to the fact that it just bundles the official Kubernetes components in a smaller, easy-to-install package. What makes k3s different from other smaller Kubernetes distributions, is that it is intended for production use, whereas projects like microk8s or Minikube are more suitable for development purposes, and the fact that it is very lightweight and runs nicely on also on ARM-based hardware. In k3s, the essentials of a Kubernetes system have been combined into a single 40 meg binary that integrates all the required components and processes.</div><div><br /></div><div>K3s will run pretty much on almost any Linux distribution, and we decided to go with <a href="https://www.raspberrypi.org/downloads/raspbian/">Raspbian Stretch Lite</a> as the base OS because we don’t need any additional services or desktop user interfaces on the boards. K3s does require cgroups to be enabled in the Linux kernel, and this can be done on Raspbian by adding the following parameters to <code>/boot/cmdline.txt</code>:<br /><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="d93a810a453bc95b5e8edd31119a68e8"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-raspian-boot-cmdline-txt"><div class="Box-body p-0 blob-wrapper data type-text " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-raspian-boot-cmdline-txt-LC1">cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory</td>      </tr></tbody></table></div></div></div></div></div></div></div><h3><span style="font-family: inherit;">Installing k3s</span></h3></div><div><span style="font-family: inherit;">The authors of k3s have done a nice job with smoothing the installation process. Once you have your server hardware ready, it is super easy to setup in just a couple of minutes: it takes only one command to install the server (master node):</span><br /><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="ff19fc5266ea034d214628654ea8c52f" data-gist-line="3"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-gistfile1-txt"><div class="Box-body p-0 blob-wrapper data type-text " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-gistfile1-txt-LC3">curl -sfL https://get.k3s.io | sh -</td>      </tr></tbody></table></div></div></div></div></div></div></div><span style="font-family: inherit;">and the same goes for agent nodes:</span><br /><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="ff19fc5266ea034d214628654ea8c52f" data-gist-line="4"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-gistfile1-txt"><div class="Box-body p-0 blob-wrapper data type-text " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-gistfile1-txt-LC4">curl -sfL https://get.k3s.io | K3S_TOKEN=&lt;token_from_server&gt; K3S_URL=https://&lt;server_ip&gt;:6443 sh -</td>      </tr></tbody></table></div></div></div></div></div></div></div><span style="font-family: inherit;">where <code>token_from_server</code> is the contents of the file <code>/var/lib/rancher/k3s/server/node-token</code> from the server and <code>server_ip</code> is the IP address of the server node. At this point, our cluster was already up and running, and we could start deploying workloads:</span></div><div class="gist" id="gist95416575"><div class="gist-file"><div class="gist-data"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-gistfile1-txt"><div class="Box-body p-0 blob-wrapper data type-text " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>        <td id="file-gistfile1-txt-L1" class="blob-num js-line-number" data-line-number="1"></td>        <td id="file-gistfile1-txt-LC1" class="blob-code blob-code-inner js-file-line">root@k3s-server:~# kubectl get nodes</td>      </tr>      <tr>        <td id="file-gistfile1-txt-L2" class="blob-num js-line-number" data-line-number="2"></td>        <td id="file-gistfile1-txt-LC2" class="blob-code blob-code-inner js-file-line">NAME         STATUS   ROLES    AGE    VERSION</td>      </tr>      <tr>        <td id="file-gistfile1-txt-L3" class="blob-num js-line-number" data-line-number="3"></td>        <td id="file-gistfile1-txt-LC3" class="blob-code blob-code-inner js-file-line">k3s-node1    Ready    &lt;none&gt;   40s    v1.13.4-k3s.1</td>      </tr>      <tr>        <td id="file-gistfile1-txt-L4" class="blob-num js-line-number" data-line-number="4"></td>        <td id="file-gistfile1-txt-LC4" class="blob-code blob-code-inner js-file-line">k3s-server   Ready    &lt;none&gt;   108s   v1.13.4-k3s.1</td>      </tr></tbody></table></div></div></div></div></div></div>For administering and monitoring the cluster, we installed <a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Kubernetes Dashboard</a>, which provides a convenient web interface for checking the overall system status, performing admin operations and accessing logs. Installing and running kubectl command locally is also very helpful because it allows administering the cluster from your own computer without needing to ssh into the cluster. To do that, you just <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">install kubectl</a> and copy the cluster information from the server node config <code>/etc/rancher/k3s/k3s.yaml</code> into the local kubeconfig file (usually <code>${HOME}/.kube/config</code>).<br /><h3>Exposing the services with a load balancer</h3><div>By default, the applications deployed to a Kubernetes cluster are only reachable from within the cluster (default service type is <code>ClusterIP</code>). To make them reachable from outside the cluster, there are two options. You can either configure the service with the type <code>NodePort</code>, which exposes the service on each node's IP at a static port, or you can use a load balancer (service type <code>LoadBalancer</code>). NodePort services are, however, quite limited: they use their own dedicated port range and we can only differentiate apps by their port number. K3s does also provide a simple built-in service load balancer but since it uses the nodes’ IP addresses, we might quickly run out of IP/port combinations and binding the services to a certain virtual IP is not possible. For these reasons, we decided to deploy <a href="https://metallb.universe.tf/">MetalLB</a> - a load-balancer implementation that is intended for bare metal clusters.</div><div><br /></div><div>MetalLB can be installed simply by <a href="https://metallb.universe.tf/installation/">applying the YAML manifest</a>. The simplest way to run MetalLB in an existing network is to use the so-called <a href="https://metallb.universe.tf/tutorial/layer2/">layer 2 mode</a>, which means that the cluster nodes announce the virtual IPs of the services in the local network with ARP protocol. For that purpose, we reserved a small pool of IP addresses from our internal network for the cluster services. The config for MetalLB thus looked like this:<br /><div class="gist" id="gist95332783"><div class="gist-file"><div class="gist-data"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-metallb-config-yaml"><div class="Box-body p-0 blob-wrapper data type-yaml " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>        <td id="file-metallb-config-yaml-L1" class="blob-num js-line-number" data-line-number="1"></td>        <td id="file-metallb-config-yaml-LC1" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">apiVersion</span>: <span class="pl-c1">v1</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L2" class="blob-num js-line-number" data-line-number="2"></td>        <td id="file-metallb-config-yaml-LC2" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">kind</span>: <span class="pl-s">ConfigMap</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L3" class="blob-num js-line-number" data-line-number="3"></td>        <td id="file-metallb-config-yaml-LC3" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">metadata</span>:</td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L4" class="blob-num js-line-number" data-line-number="4"></td>        <td id="file-metallb-config-yaml-LC4" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">namespace</span>: <span class="pl-s">metallb-system</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L5" class="blob-num js-line-number" data-line-number="5"></td>        <td id="file-metallb-config-yaml-LC5" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">name</span>: <span class="pl-s">config</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L6" class="blob-num js-line-number" data-line-number="6"></td>        <td id="file-metallb-config-yaml-LC6" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">data</span>:</td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L7" class="blob-num js-line-number" data-line-number="7"></td>        <td id="file-metallb-config-yaml-LC7" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">config</span>: <span class="pl-s">|</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L8" class="blob-num js-line-number" data-line-number="8"></td>        <td id="file-metallb-config-yaml-LC8" class="blob-code blob-code-inner js-file-line"><span class="pl-s">    address-pools:</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L9" class="blob-num js-line-number" data-line-number="9"></td>        <td id="file-metallb-config-yaml-LC9" class="blob-code blob-code-inner js-file-line"><span class="pl-s">    - name: company-office</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L10" class="blob-num js-line-number" data-line-number="10"></td>        <td id="file-metallb-config-yaml-LC10" class="blob-code blob-code-inner js-file-line"><span class="pl-s">      protocol: layer2</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L11" class="blob-num js-line-number" data-line-number="11"></td>        <td id="file-metallb-config-yaml-LC11" class="blob-code blob-code-inner js-file-line"><span class="pl-s">      addresses:</span></td>      </tr>      <tr>        <td id="file-metallb-config-yaml-L12" class="blob-num js-line-number" data-line-number="12"></td>        <td id="file-metallb-config-yaml-LC12" class="blob-code blob-code-inner js-file-line"><span class="pl-s">      - 10.10.10.50-10.10.10.99</span></td>      </tr></tbody></table></div></div></div></div></div></div>With this config, the cluster services would be exposed at addresses in the range 10.10.10.50-10.10.10.99. To bind a service to a specific IP, you can use the <code>loadBalancerIP</code> parameter in your service manifest:<br /><div class="gist" id="gist95333113"><div class="gist-file"><div class="gist-data"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-service-lb-example-yaml"><div class="Box-body p-0 blob-wrapper data type-yaml " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>        <td id="file-service-lb-example-yaml-L1" class="blob-num js-line-number" data-line-number="1"></td>        <td id="file-service-lb-example-yaml-LC1" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">apiVersion</span>: <span class="pl-c1">v1</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L2" class="blob-num js-line-number" data-line-number="2"></td>        <td id="file-service-lb-example-yaml-LC2" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">kind</span>: <span class="pl-s">Service</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L3" class="blob-num js-line-number" data-line-number="3"></td>        <td id="file-service-lb-example-yaml-LC3" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">metadata</span>:</td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L4" class="blob-num js-line-number" data-line-number="4"></td>        <td id="file-service-lb-example-yaml-LC4" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">name</span>: <span class="pl-s">my-web-app</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L5" class="blob-num js-line-number" data-line-number="5"></td>        <td id="file-service-lb-example-yaml-LC5" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">spec</span>:</td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L6" class="blob-num js-line-number" data-line-number="6"></td>        <td id="file-service-lb-example-yaml-LC6" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">ports</span>:</td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L7" class="blob-num js-line-number" data-line-number="7"></td>        <td id="file-service-lb-example-yaml-LC7" class="blob-code blob-code-inner js-file-line">  - <span class="pl-ent">name</span>: <span class="pl-s">http</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L8" class="blob-num js-line-number" data-line-number="8"></td>        <td id="file-service-lb-example-yaml-LC8" class="blob-code blob-code-inner js-file-line">    <span class="pl-ent">port</span>: <span class="pl-c1">80</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L9" class="blob-num js-line-number" data-line-number="9"></td>        <td id="file-service-lb-example-yaml-LC9" class="blob-code blob-code-inner js-file-line">    <span class="pl-ent">protocol</span>: <span class="pl-s">TCP</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L10" class="blob-num js-line-number" data-line-number="10"></td>        <td id="file-service-lb-example-yaml-LC10" class="blob-code blob-code-inner js-file-line">    <span class="pl-ent">targetPort</span>: <span class="pl-c1">8080</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L11" class="blob-num js-line-number" data-line-number="11"></td>        <td id="file-service-lb-example-yaml-LC11" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">loadBalancerIP</span>: <span class="pl-s">10.10.10.51</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L12" class="blob-num js-line-number" data-line-number="12"></td>        <td id="file-service-lb-example-yaml-LC12" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">selector</span>:</td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L13" class="blob-num js-line-number" data-line-number="13"></td>        <td id="file-service-lb-example-yaml-LC13" class="blob-code blob-code-inner js-file-line">    <span class="pl-ent">app</span>: <span class="pl-s">my-web-app</span></td>      </tr>      <tr>        <td id="file-service-lb-example-yaml-L14" class="blob-num js-line-number" data-line-number="14"></td>        <td id="file-service-lb-example-yaml-LC14" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">type</span>: <span class="pl-s">LoadBalancer</span></td>      </tr></tbody></table></div></div></div></div></div></div>It is with load balancing where we saw most of our challenges. For example, Kubernetes has a <a href="https://github.com/kubernetes/kubernetes/issues/23880">limitation</a> that prevents having both TCP and UDP ports in a single load balancer service. To work around that, you can define two service instances, one for TCP ports and another for UDP ports. The downside is that then you will run these two services in different IP addresses, unless you enable <a href="https://metallb.universe.tf/usage/#ip-address-sharing">IP address sharing</a>. And as MetalLB is a young project, there was a small <a href="https://github.com/google/metallb/issues/335">wrinkle</a> with this as well, but we are confident that all these will be ironed out soon.<br /><h3>Adding storage</h3></div><div>K3s doesn't have a built-in storage solution yet, so in order to give the pods access to persistent file storage, we need create one by using one of the <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes">plugins supported by Kubernetes</a>. Since one of the goals of Kubernetes is to decouple the applications from the infrastructure and make them portable, the Kubernetes storage lingo defines an abstraction layer for storage with the concepts of <i>PersistentVolume</i> (PV) and <i>PersistentVolumeClaim</i> (PVC). PVs are storage resources that are typically configured and made available for the apps by the administrator. PVCs, on the other hand, describe the application's need for a certain kind and amount of storage. When a PVC is created (typically as part of the application), it is bound to a PV, if there is one available that is not yet in use and satisfies the app's PVC requirements. Configuring and maintaining all this would mean manual work, which is why there is a way to <a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/">provision volumes dynamically</a>.</div><div><br /></div><div>In our infrastructure we already had an existing NFS server available, so we decided to use that for the cluster persistent file storage. The easiest way to accomplish this in our case was by using <a href="https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client">NFS-Client Provisioner</a> that supports dynamic provisioning of PVs. The provisioner simply creates new directories on the existing NFS share for each new PV (that the cluster maps to a PVC) and then the PV directory is mounted in the container where it is used. This way there is no need to configure the NFS shares into volumes in individual pods but it all works dynamically.</div><h3>Cross-building container images for ARM</h3><div>Obviously, when running app containers on ARM-based hardware like Raspberry Pi, the containers need to be built for ARM architecture. There are a few gotchas that you might face when building your own apps into ARM architecture containers. First of all, the base image needs to be available for your target architecture. In the case of Raspberry Pi 3, you typically want to use an "arm32v7" base image, <a href="https://github.com/docker-library/official-images#architectures-other-than-amd64">as they are called in most Docker registries</a>. So, when cross-building your app, make sure your Dockerfile contains e.g.</div><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="8252b6b7796f37b50412e89129c9d3ea" data-gist-line="1"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-dockerfile"><div class="Box-body p-0 blob-wrapper data type-dockerfile " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-dockerfile-LC1"><span class="pl-k">FROM</span> arm32v7/alpine:latest</td>      </tr></tbody></table></div></div></div></div></div></div></div><div>The second thing to note is that your host Docker needs to be able to run ARM binaries. If you are running Docker for Mac, things are easy because it has built-in support for this. On Linux, there are a few steps that you must take, outlined below.<br /><h3>Adding QEMU binary into your base image</h3></div><div>To run ARM binaries in Docker on Linux, the image needs have a QEMU binary. You can either choose a base image that already contains the QEMU binary, like the images from <a href="https://www.balena.io/">Balena</a>, or copy the <code>qemu-arm-static</code> binary into the image during build, e.g. by adding the following line into your Dockerfile:</div><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="8252b6b7796f37b50412e89129c9d3ea" data-gist-line="2"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-dockerfile"><div class="Box-body p-0 blob-wrapper data type-dockerfile " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-dockerfile-LC2"><span class="pl-k">COPY</span> --from=biarms/qemu-bin /usr/bin/qemu-arm-static /usr/bin/qemu-arm-static</td>      </tr></tbody></table></div></div></div></div></div></div></div><br /><div><div class="notice"><i>Security notice: Please be aware that downloading and running an unknown container is like downloading and running an unknown EXE. For anything else but hobby projects, you should always use either scanned/vetted images (e.g. Docker Official Images) or container images from trusted organizations or companies.</i></div><br />Then, QEMU needs be registered on your host OS where you create your Docker images. This can be achieved simply with:<br /><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="ff19fc5266ea034d214628654ea8c52f" data-gist-line="8"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-gistfile1-txt"><div class="Box-body p-0 blob-wrapper data type-text " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-gistfile1-txt-LC8">docker run --rm --privileged multiarch/qemu-user-static:register --reset</td>      </tr></tbody></table></div></div></div></div></div></div></div>This command can be added into your build script before building the actual image. To wrap things up, your <code>Dockerfile.arm</code> would look e.g. something like this:</div><div class="gist" id="gist95334484"><div class="gist-file"><div class="gist-data"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-dockerfile"><div class="Box-body p-0 blob-wrapper data type-dockerfile " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>        <td class="blob-num js-line-number" data-line-number="1" id="file-dockerfile-L1"></td>        <td class="blob-code blob-code-inner js-file-line" id="file-dockerfile-LC1"><span class="pl-k">FROM</span> arm32v7/alpine:latest</td>      </tr><tr>        <td class="blob-num js-line-number" data-line-number="2" id="file-dockerfile-L2"></td>        <td class="blob-code blob-code-inner js-file-line" id="file-dockerfile-LC2"><span class="pl-k">COPY</span> --from=biarms/qemu-bin /usr/bin/qemu-arm-static /usr/bin/qemu-arm-static</td>      </tr><tr>        <td class="blob-num js-line-number" data-line-number="3" id="file-dockerfile-L3"></td>        <td class="blob-code blob-code-inner js-file-line" id="file-dockerfile-LC3"></td>      </tr><tr>        <td class="blob-num js-line-number" data-line-number="4" id="file-dockerfile-L4"></td>        <td class="blob-code blob-code-inner js-file-line" id="file-dockerfile-LC4"><span class="pl-c"><span class="pl-c">#</span> commands to build your app go here…</span></td>      </tr><tr>        <td class="blob-num js-line-number" data-line-number="5" id="file-dockerfile-L5"></td>        <td class="blob-code blob-code-inner js-file-line" id="file-dockerfile-LC5"><span class="pl-c"><span class="pl-c">#</span> e.g. RUN apk add --update &lt;pkgs that you need…&gt;</span></td>      </tr></tbody></table></div></div></div></div></div></div>and your build/CI script is essentially:<br /><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="ff19fc5266ea034d214628654ea8c52f" data-gist-line="8-9"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-gistfile1-txt"><div class="Box-body p-0 blob-wrapper data type-text " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-gistfile1-txt-LC8">docker run --rm --privileged multiarch/qemu-user-static:register --reset</td>      </tr><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-gistfile1-txt-LC9">docker build -t my-custom-image-arm . -f Dockerfile.arm</td>      </tr></tbody></table></div></div></div></div></div></div></div>which will give you an ARM architecture container image as a result. For those who are interested in the details, there is more information available on <a href="https://www.ecliptik.com/Cross-Building-and-Running-Multi-Arch-Docker-Images/">cross-building</a> and if your registry supports v2.2 manifests, the different architectures can be even combined into a <a href="https://lobradov.github.io/Building-docker-multiarch-images/">multi-arch image</a>.<br /><h3>Automating builds and registry uploads</h3><div>The final step is to automate the whole process so that the container images are built automatically and uploaded to a registry from where they can easily be deployed to our k3s cluster. Internally, we are using <a href="https://about.gitlab.com/">GitLab</a> for our source code management and CI/CD, so we naturally wanted to get these builds running in there. It even includes a built-in <a href="https://docs.gitlab.com/ee/user/project/container_registry.html">container registry</a>, so there was no need to set up a separate one.</div><div><br /></div><div>GitLab has <a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html">good documentation</a> on building Docker images, so we won't repeat all the stuff here. After configuring the GitLab Runner for docker builds, all there is left to do is to create a <code>.gitlab-ci.yml</code> file for the project. In our case it looked like this:</div><div class="gist" id="gist95334823"><div class="gist-file"><div class="gist-data"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-gitlab-ci-yml"><div class="Box-body p-0 blob-wrapper data type-yaml " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>        <td id="file-gitlab-ci-yml-L1" class="blob-num js-line-number" data-line-number="1"></td>        <td id="file-gitlab-ci-yml-LC1" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">image</span>: <span class="pl-s">docker:stable</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L2" class="blob-num js-line-number" data-line-number="2"></td>        <td id="file-gitlab-ci-yml-LC2" class="blob-code blob-code-inner js-file-line"></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L3" class="blob-num js-line-number" data-line-number="3"></td>        <td id="file-gitlab-ci-yml-LC3" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">stages</span>:</td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L4" class="blob-num js-line-number" data-line-number="4"></td>        <td id="file-gitlab-ci-yml-LC4" class="blob-code blob-code-inner js-file-line">  - <span class="pl-s">build</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L5" class="blob-num js-line-number" data-line-number="5"></td>        <td id="file-gitlab-ci-yml-LC5" class="blob-code blob-code-inner js-file-line">  - <span class="pl-s">release</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L6" class="blob-num js-line-number" data-line-number="6"></td>        <td id="file-gitlab-ci-yml-LC6" class="blob-code blob-code-inner js-file-line"> </td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L7" class="blob-num js-line-number" data-line-number="7"></td>        <td id="file-gitlab-ci-yml-LC7" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">variables</span>:</td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L8" class="blob-num js-line-number" data-line-number="8"></td>        <td id="file-gitlab-ci-yml-LC8" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">DOCKER_DRIVER</span>: <span class="pl-s">overlay2</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L9" class="blob-num js-line-number" data-line-number="9"></td>        <td id="file-gitlab-ci-yml-LC9" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">CONTAINER_TEST_IMAGE</span>: <span class="pl-s">${CI_REGISTRY_IMAGE}/${CI_PROJECT_NAME}-arm:${CI_COMMIT_REF_SLUG}</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L10" class="blob-num js-line-number" data-line-number="10"></td>        <td id="file-gitlab-ci-yml-LC10" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">CONTAINER_RELEASE_IMAGE</span>: <span class="pl-s">${CI_REGISTRY_IMAGE}/${CI_PROJECT_NAME}-arm:latest</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L11" class="blob-num js-line-number" data-line-number="11"></td>        <td id="file-gitlab-ci-yml-LC11" class="blob-code blob-code-inner js-file-line"> </td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L12" class="blob-num js-line-number" data-line-number="12"></td>        <td id="file-gitlab-ci-yml-LC12" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">before_script</span>:</td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L13" class="blob-num js-line-number" data-line-number="13"></td>        <td id="file-gitlab-ci-yml-LC13" class="blob-code blob-code-inner js-file-line">- <span class="pl-s">docker info</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L14" class="blob-num js-line-number" data-line-number="14"></td>        <td id="file-gitlab-ci-yml-LC14" class="blob-code blob-code-inner js-file-line">- <span class="pl-s">docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L15" class="blob-num js-line-number" data-line-number="15"></td>        <td id="file-gitlab-ci-yml-LC15" class="blob-code blob-code-inner js-file-line"> </td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L16" class="blob-num js-line-number" data-line-number="16"></td>        <td id="file-gitlab-ci-yml-LC16" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">build_image</span>:</td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L17" class="blob-num js-line-number" data-line-number="17"></td>        <td id="file-gitlab-ci-yml-LC17" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">stage</span>: <span class="pl-s">build</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L18" class="blob-num js-line-number" data-line-number="18"></td>        <td id="file-gitlab-ci-yml-LC18" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">script</span>:</td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L19" class="blob-num js-line-number" data-line-number="19"></td>        <td id="file-gitlab-ci-yml-LC19" class="blob-code blob-code-inner js-file-line">    - <span class="pl-s">docker pull $CONTAINER_RELEASE_IMAGE || true</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L20" class="blob-num js-line-number" data-line-number="20"></td>        <td id="file-gitlab-ci-yml-LC20" class="blob-code blob-code-inner js-file-line">    - <span class="pl-s">docker run --rm --privileged multiarch/qemu-user-static:register --reset</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L21" class="blob-num js-line-number" data-line-number="21"></td>        <td id="file-gitlab-ci-yml-LC21" class="blob-code blob-code-inner js-file-line">    - <span class="pl-s">docker build --cache-from $CONTAINER_RELEASE_IMAGE -t $CONTAINER_TEST_IMAGE . -f Dockerfile.arm</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L22" class="blob-num js-line-number" data-line-number="22"></td>        <td id="file-gitlab-ci-yml-LC22" class="blob-code blob-code-inner js-file-line">    - <span class="pl-s">docker push $CONTAINER_TEST_IMAGE</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L23" class="blob-num js-line-number" data-line-number="23"></td>        <td id="file-gitlab-ci-yml-LC23" class="blob-code blob-code-inner js-file-line"> </td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L24" class="blob-num js-line-number" data-line-number="24"></td>        <td id="file-gitlab-ci-yml-LC24" class="blob-code blob-code-inner js-file-line"><span class="pl-ent">release</span>:</td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L25" class="blob-num js-line-number" data-line-number="25"></td>        <td id="file-gitlab-ci-yml-LC25" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">stage</span>: <span class="pl-s">release</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L26" class="blob-num js-line-number" data-line-number="26"></td>        <td id="file-gitlab-ci-yml-LC26" class="blob-code blob-code-inner js-file-line">  <span class="pl-ent">script</span>:</td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L27" class="blob-num js-line-number" data-line-number="27"></td>        <td id="file-gitlab-ci-yml-LC27" class="blob-code blob-code-inner js-file-line">    - <span class="pl-s">docker pull $CONTAINER_TEST_IMAGE</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L28" class="blob-num js-line-number" data-line-number="28"></td>        <td id="file-gitlab-ci-yml-LC28" class="blob-code blob-code-inner js-file-line">    - <span class="pl-s">docker tag $CONTAINER_TEST_IMAGE $CONTAINER_RELEASE_IMAGE</span></td>      </tr>      <tr>        <td id="file-gitlab-ci-yml-L29" class="blob-num js-line-number" data-line-number="29"></td>        <td id="file-gitlab-ci-yml-LC29" class="blob-code blob-code-inner js-file-line">    - <span class="pl-s">docker push $CONTAINER_RELEASE_IMAGE</span></td>      </tr></tbody></table></div></div></div></div></div></div>Now that we have our images in the container registry, we just need to deploy them into our cluster. To grant our cluster access to the registry, we create a <a href="https://docs.gitlab.com/ee/user/project/deploy_tokens/">deploy token</a> in GitLab and then add the token credentials into the cluster as a docker-registry secret:<br /><div data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="ff19fc5266ea034d214628654ea8c52f" data-gist-line="11"><div class="gist"><div class="gist-file" style="border-bottom: 1px solid rgb(221, 221, 221);"><div class="gist-data" style="border-bottom: 0px;"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-gistfile1-txt"><div class="Box-body p-0 blob-wrapper data type-text " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>                 <td class="blob-code blob-code-inner js-file-line" id="file-gistfile1-txt-LC11">kubectl create secret docker-registry deploycred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;token-username&gt; --docker-password=&lt;token-password&gt; --docker-email=&lt;your-email&gt;</td>      </tr></tbody></table></div></div></div></div></div></div></div>After that the deploy token secret can be used in the YAML file PodSpec:<br /><div class="gist" id="gist95334878"><div class="gist-file"><div class="gist-data"><div class="js-gist-file-update-container js-task-list-container file-box"><div class="file" id="file-deploy-token-secret-yaml"><div class="Box-body p-0 blob-wrapper data type-yaml " itemprop="text"><table class="highlight tab-size js-file-line-container" data-tab-size="8">      <tbody><tr>        <td id="file-deploy-token-secret-yaml-L1" class="blob-num js-line-number" data-line-number="1"></td>        <td id="file-deploy-token-secret-yaml-LC1" class="blob-code blob-code-inner js-file-line">     <span class="pl-ent">imagePullSecrets</span>:</td>      </tr>      <tr>        <td id="file-deploy-token-secret-yaml-L2" class="blob-num js-line-number" data-line-number="2"></td>        <td id="file-deploy-token-secret-yaml-LC2" class="blob-code blob-code-inner js-file-line">      - <span class="pl-ent">name</span>: <span class="pl-s">deploycred</span></td>      </tr>      <tr>        <td id="file-deploy-token-secret-yaml-L3" class="blob-num js-line-number" data-line-number="3"></td>        <td id="file-deploy-token-secret-yaml-LC3" class="blob-code blob-code-inner js-file-line">     <span class="pl-ent">containers</span>:</td>      </tr>      <tr>        <td id="file-deploy-token-secret-yaml-L4" class="blob-num js-line-number" data-line-number="4"></td>        <td id="file-deploy-token-secret-yaml-LC4" class="blob-code blob-code-inner js-file-line">      - <span class="pl-ent">name</span>: <span class="pl-s">myapp</span></td>      </tr>      <tr>        <td id="file-deploy-token-secret-yaml-L5" class="blob-num js-line-number" data-line-number="5"></td>        <td id="file-deploy-token-secret-yaml-LC5" class="blob-code blob-code-inner js-file-line">        <span class="pl-ent">image</span>: <span class="pl-s">gitlab.mycompany.com:4567/my/project/my-app-arm:latest</span></td>      </tr></tbody></table> </div></div></div></div></div></div>With all these pieces in place, there we finally have it: an automated CI/CD pipeline from source code to ARM container images in a private registry, ready to be deployed into the cluster. <h3>Conclusions</h3><div><div><a href="https://2.bp.blogspot.com/-thhv7H5k9oE/XKEKmB4HJqI/AAAAAAAAAFs/8kSoVgTvDv8JA3AXTcdbU4HhXDYX6gVngCLcBGAs/s1600/IMG_6910.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" data-original-height="1600" data-original-width="1200" height="320" src="https://2.bp.blogspot.com/-thhv7H5k9oE/XKEKmB4HJqI/AAAAAAAAAFs/8kSoVgTvDv8JA3AXTcdbU4HhXDYX6gVngCLcBGAs/s320/IMG_6910.jpg" width="240" /></a>All-in-all, it turned out that getting your own bare-metal Kubernetes cluster up and running was easier than expected. There are some rough edges and limitations coming from the fact that this technology has its roots in the cloud but nevertheless, k3s proved to be a sound choice for running containerised services at the edge and on lower-spec hardware in general.</div><div><br /></div><div>One small downside is that k3s doesn’t support high-availability (multi-master configuration) yet. Although a single master setup is already quite resilient because the services continue running on the agent nodes even if the master goes offline, we’d like to get some redundancy also for the master node. Apparently, this feature is in the works, but until it is available, we recommend taking backups from the server node configuration.</div></div><div style="clear: both;"></div><div><br /></div><div><br /></div><div><i><a href="https://boogiesoftware.com/">Boogie Software Oy</a> is a private Finnish company headquartered in Oulu, Finland. Our unique company profile builds upon top level software competence, entrepreneurial spirit and humane work ethics. The key to our success is close co-operation with the most demanding customers, understanding their business and providing accurate software solutions for complex problems.</i></div><div><br /></div>